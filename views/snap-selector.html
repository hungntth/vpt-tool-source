<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ch·ªçn ƒëi·ªÉm tr√™n ·∫£nh</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            font-family: Arial, sans-serif;
            background: #1e1e1e;
            color: #fff;
            overflow: hidden;
        }
        .container {
            width: 100vw;
            height: 100vh;
            display: flex;
            flex-direction: column;
        }
        .toolbar {
            background: #2d2d2d;
            padding: 10px;
            display: flex;
            align-items: center;
            gap: 10px;
            border-bottom: 1px solid #444;
        }
        .toolbar button {
            padding: 6px 12px;
            background: #007acc;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
        }
        .toolbar button:hover {
            background: #005a9e;
        }
        .toolbar button.danger {
            background: #d32f2f;
        }
        .toolbar button.danger:hover {
            background: #b71c1c;
        }
        .toolbar .info {
            margin-left: auto;
            font-size: 12px;
            color: #aaa;
        }
        .image-container {
            flex: 1;
            overflow: auto;
            position: relative;
            display: flex;
            align-items: center;
            justify-content: center;
            background: #1e1e1e;
        }
        .image-wrapper {
            position: relative;
            display: inline-block;
        }
        #snapImage {
            max-width: 100%;
            max-height: 100%;
            display: block;
            cursor: crosshair;
            user-select: none;
        }
        .selection-box {
            position: absolute;
            border: 2px dashed #00ff00;
            background: rgba(0, 255, 0, 0.1);
            pointer-events: none;
            display: none;
        }
        .selection-box.active {
            display: block;
        }
        .click-point {
            position: absolute;
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background: #ff0000;
            border: 2px solid #fff;
            transform: translate(-50%, -50%);
            pointer-events: none;
            box-shadow: 0 0 4px rgba(0, 0, 0, 0.5);
        }
        .click-point::after {
            content: attr(data-index);
            position: absolute;
            top: 15px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.8);
            color: #fff;
            padding: 2px 6px;
            border-radius: 3px;
            font-size: 10px;
            white-space: nowrap;
        }
        .instructions {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(0, 0, 0, 0.8);
            padding: 10px;
            border-radius: 4px;
            font-size: 11px;
            line-height: 1.6;
            z-index: 1000;
        }
        .instructions strong {
            color: #00ff00;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="toolbar">
            <button id="clearSelectionBtn">üóëÔ∏è X√≥a khu v·ª±c</button>
            <button id="clearPointsBtn">üóëÔ∏è X√≥a ƒëi·ªÉm</button>
            <button id="clearAllBtn" class="danger">üóëÔ∏è X√≥a t·∫•t c·∫£</button>
            <div class="info">
                <span id="selectionInfo">Ch∆∞a ch·ªçn khu v·ª±c</span> | 
                <span id="pointsInfo">0 ƒëi·ªÉm click</span>
            </div>
            <button id="saveBtn" style="margin-left: auto;">üíæ L∆∞u v√† ƒë√≥ng</button>
        </div>
        <div class="image-container">
            <div class="instructions">
                <strong>H∆∞·ªõng d·∫´n:</strong><br>
                ‚Ä¢ Chu·ªôt tr√°i: K√©o ƒë·ªÉ ch·ªçn khu v·ª±c so s√°nh<br>
                ‚Ä¢ Chu·ªôt ph·∫£i: Click ƒë·ªÉ ch·ªçn ƒëi·ªÉm auto click<br>
                ‚Ä¢ Khu v·ª±c: D√πng ƒë·ªÉ t√¨m ki·∫øm h√¨nh ·∫£nh<br>
                ‚Ä¢ ƒêi·ªÉm: V·ªã tr√≠ s·∫Ω ƒë∆∞·ª£c click t·ª± ƒë·ªông
            </div>
            <div class="image-wrapper">
                <img id="snapImage" src="" alt="Screenshot">
            </div>
        </div>
    </div>
    <script>
        const { ipcRenderer } = require('electron');

        let imageElement = null;
        let imageWrapper = null;
        let isSelecting = false;
        let startX = 0;
        let startY = 0;
        let currentSelections = []; // M·∫£ng c√°c selection ƒëang ƒë∆∞·ª£c v·∫Ω
        let currentSelectionIndex = -1; // Index c·ªßa selection ƒëang ƒë∆∞·ª£c v·∫Ω
        let clickPoints = []; // M·ªói ƒëi·ªÉm c√≥ selections: [{offsetX, offsetY, selections: [{x, y, width, height}]}]
        let imageScaleX = 1;
        let imageScaleY = 1;
        let imageOffsetX = 0;
        let imageOffsetY = 0;
        let currentImagePath = null;
        let tempSelectionBox = null; // Selection box t·∫°m khi ƒëang v·∫Ω

        function init() {
            try {
                imageElement = document.getElementById('snapImage');
                imageWrapper = document.querySelector('.image-wrapper');

                if (!imageElement) {
                    console.error('[Snap Selector] L·ªói: Kh√¥ng t√¨m th·∫•y element #snapImage');
                    return;
                }
                if (!imageWrapper) {
                    console.error('[Snap Selector] L·ªói: Kh√¥ng t√¨m th·∫•y element .image-wrapper');
                    return;
                }
                
                // T·∫°o selection box t·∫°m
                tempSelectionBox = document.createElement('div');
                tempSelectionBox.className = 'selection-box';
                imageWrapper.appendChild(tempSelectionBox);

                console.log('[Snap Selector] ƒê√£ kh·ªüi t·∫°o th√†nh c√¥ng');
            } catch (error) {
                console.error('[Snap Selector] L·ªói khi kh·ªüi t·∫°o:', error);
                return;
            }

            // Nh·∫≠n d·ªØ li·ªáu ·∫£nh t·ª´ main process
            ipcRenderer.on('snap-image-data', (event, data) => {
                try {
                    console.log('[Snap Selector] Nh·∫≠n d·ªØ li·ªáu ·∫£nh:', { 
                        hasDataUrl: !!data?.imageDataUrl,
                        hasImagePath: !!data?.imagePath,
                        hasWindowRect: !!data?.windowRect,
                        hasEditData: !!data?.editData
                    });
                    
                    if (!data) {
                        console.error('[Snap Selector] L·ªói: Kh√¥ng c√≥ d·ªØ li·ªáu nh·∫≠n ƒë∆∞·ª£c');
                        return;
                    }
                    
                    if (!data.imageDataUrl) {
                        console.error('[Snap Selector] L·ªói: Kh√¥ng c√≥ imageDataUrl trong d·ªØ li·ªáu:', data);
                        return;
                    }
                    
                    if (!imageElement) {
                        console.error('[Snap Selector] L·ªói: imageElement ch∆∞a ƒë∆∞·ª£c kh·ªüi t·∫°o');
                        return;
                    }
                    
                    // L∆∞u imagePath
                    currentImagePath = data.imagePath || null;
                    
                    // Reset c√°c ƒëi·ªÉm v√† selections tr∆∞·ªõc khi load ·∫£nh m·ªõi
                    clickPoints = [];
                    currentSelections = [];
                    currentSelectionIndex = -1;
                    clearAllSelectionBoxes();
                    
                    imageElement.src = data.imageDataUrl;
                    imageElement.onload = () => {
                        try {
                            console.log('[Snap Selector] ·∫¢nh ƒë√£ load th√†nh c√¥ng:', {
                                naturalWidth: imageElement.naturalWidth,
                                naturalHeight: imageElement.naturalHeight,
                                width: imageElement.width,
                                height: imageElement.height
                            });
                            updateImageScale();
                            
                            // N·∫øu c√≥ editData, load l·∫°i c√°c ƒëi·ªÉm v√† selection c≈©
                            if (data.editData) {
                                console.log('[Snap Selector] ƒêang load d·ªØ li·ªáu edit:', data.editData);
                                
                                // Load ƒëi·ªÉm click n·∫øu c√≥
                                if (typeof data.editData.offsetX === 'number' && typeof data.editData.offsetY === 'number') {
                                    const rect = imageElement.getBoundingClientRect();
                                    const scaleX = rect.width / imageElement.naturalWidth;
                                    const scaleY = rect.height / imageElement.naturalHeight;
                                    
                                    const displayX = data.editData.offsetX * scaleX;
                                    const displayY = data.editData.offsetY * scaleY;
                                    
                                    // Load selections n·∫øu c√≥ (c√≥ th·ªÉ l√† m·∫£ng ho·∫∑c object ƒë∆°n)
                                    let selections = [];
                                    if (data.editData.selections && Array.isArray(data.editData.selections)) {
                                        selections = data.editData.selections;
                                    } else if (data.editData.selection) {
                                        // Backward compatibility: n·∫øu c√≥ selection ƒë∆°n, chuy·ªÉn th√†nh m·∫£ng
                                        selections = [data.editData.selection];
                                    }
                                    
                                    addClickPoint(data.editData.offsetX, data.editData.offsetY, displayX, displayY, selections);
                                }
                            }
                        } catch (error) {
                            console.error('[Snap Selector] L·ªói trong imageElement.onload:', error);
                        }
                    };
                    imageElement.onerror = (error) => {
                        console.error('[Snap Selector] L·ªói khi load ·∫£nh:', error);
                        console.error('[Snap Selector] imageDataUrl length:', data.imageDataUrl?.length);
                    };
                } catch (error) {
                    console.error('[Snap Selector] L·ªói khi x·ª≠ l√Ω snap-image-data:', error);
                }
            });

            // Chu·ªôt tr√°i: K√©o ƒë·ªÉ ch·ªçn khu v·ª±c
            imageElement.addEventListener('mousedown', (e) => {
                if (e.button === 0) { // Chu·ªôt tr√°i
                    e.preventDefault();
                    isSelecting = true;
                    const rect = imageElement.getBoundingClientRect();
                    startX = e.clientX - rect.left;
                    startY = e.clientY - rect.top;
                    currentSelectionIndex = currentSelections.length;
                    currentSelections.push({ x: startX, y: startY, width: 0, height: 0 });
                    if (tempSelectionBox) {
                        tempSelectionBox.style.display = 'block';
                        tempSelectionBox.style.left = startX + 'px';
                        tempSelectionBox.style.top = startY + 'px';
                        tempSelectionBox.style.width = '0px';
                        tempSelectionBox.style.height = '0px';
                    }
                }
            });

            imageElement.addEventListener('mousemove', (e) => {
                if (isSelecting && currentSelectionIndex >= 0) {
                    const rect = imageElement.getBoundingClientRect();
                    const currentX = e.clientX - rect.left;
                    const currentY = e.clientY - rect.top;
                    
                    const left = Math.min(startX, currentX);
                    const top = Math.min(startY, currentY);
                    const width = Math.abs(currentX - startX);
                    const height = Math.abs(currentY - startY);

                    if (tempSelectionBox) {
                        tempSelectionBox.style.left = left + 'px';
                        tempSelectionBox.style.top = top + 'px';
                        tempSelectionBox.style.width = width + 'px';
                        tempSelectionBox.style.height = height + 'px';
                    }
                    
                    // C·∫≠p nh·∫≠t selection trong m·∫£ng
                    if (currentSelections[currentSelectionIndex]) {
                        currentSelections[currentSelectionIndex] = { x: left, y: top, width, height };
                    }
                }
            });

            imageElement.addEventListener('mouseup', (e) => {
                if (e.button === 0 && isSelecting) { // Chu·ªôt tr√°i
                    isSelecting = false;
                    const rect = imageElement.getBoundingClientRect();
                    const endX = e.clientX - rect.left;
                    const endY = e.clientY - rect.top;
                    
                    const left = Math.min(startX, endX);
                    const top = Math.min(startY, endY);
                    const width = Math.abs(endX - startX);
                    const height = Math.abs(endY - startY);

                    if (width > 5 && height > 5) {
                        // Chuy·ªÉn ƒë·ªïi t·ªça ƒë·ªô t·ª´ ·∫£nh hi·ªÉn th·ªã v·ªÅ ·∫£nh g·ªëc
                        const scaleX = imageElement.naturalWidth / rect.width;
                        const scaleY = imageElement.naturalHeight / rect.height;
                        
                        const selection = {
                            x: Math.round(left * scaleX),
                            y: Math.round(top * scaleY),
                            width: Math.round(width * scaleX),
                            height: Math.round(height * scaleY)
                        };
                        
                        // C·∫≠p nh·∫≠t selection trong m·∫£ng
                        if (currentSelectionIndex >= 0 && currentSelections[currentSelectionIndex]) {
                            currentSelections[currentSelectionIndex] = selection;
                            renderSelectionBoxes();
                        }
                        updateSelectionInfo();
                    } else {
                        // X√≥a selection nh·ªè qu√°
                        if (currentSelectionIndex >= 0) {
                            currentSelections.splice(currentSelectionIndex, 1);
                            currentSelectionIndex = -1;
                        }
                        if (tempSelectionBox) {
                            tempSelectionBox.style.display = 'none';
                        }
                        renderSelectionBoxes();
                        updateSelectionInfo();
                    }
                }
            });

            // Chu·ªôt ph·∫£i: Click ƒë·ªÉ ch·ªçn ƒëi·ªÉm
            imageElement.addEventListener('contextmenu', (e) => {
                try {
                    e.preventDefault();
                    
                    if (!imageElement) {
                        console.error('[Snap Selector] L·ªói: imageElement kh√¥ng t·ªìn t·∫°i khi click chu·ªôt ph·∫£i');
                        return;
                    }
                    
                    const rect = imageElement.getBoundingClientRect();
                    console.log('[Snap Selector] Click chu·ªôt ph·∫£i:', {
                        clientX: e.clientX,
                        clientY: e.clientY,
                        rectLeft: rect.left,
                        rectTop: rect.top,
                        rectWidth: rect.width,
                        rectHeight: rect.height,
                        naturalWidth: imageElement.naturalWidth,
                        naturalHeight: imageElement.naturalHeight
                    });
                    
                    const x = e.clientX - rect.left;
                    const y = e.clientY - rect.top;
                    
                    if (imageElement.naturalWidth === 0 || imageElement.naturalHeight === 0) {
                        console.error('[Snap Selector] L·ªói: ·∫¢nh ch∆∞a load ho·∫∑c k√≠ch th∆∞·ªõc kh√¥ng h·ª£p l·ªá:', {
                            naturalWidth: imageElement.naturalWidth,
                            naturalHeight: imageElement.naturalHeight
                        });
                        return;
                    }
                    
                    if (rect.width === 0 || rect.height === 0) {
                        console.error('[Snap Selector] L·ªói: K√≠ch th∆∞·ªõc rect kh√¥ng h·ª£p l·ªá:', {
                            rectWidth: rect.width,
                            rectHeight: rect.height
                        });
                        return;
                    }
                    
                    // Chuy·ªÉn ƒë·ªïi t·ªça ƒë·ªô t·ª´ ·∫£nh hi·ªÉn th·ªã v·ªÅ ·∫£nh g·ªëc
                    const scaleX = imageElement.naturalWidth / rect.width;
                    const scaleY = imageElement.naturalHeight / rect.height;
                    
                    if (!isFinite(scaleX) || !isFinite(scaleY)) {
                        console.error('[Snap Selector] L·ªói: Scale kh√¥ng h·ª£p l·ªá:', {
                            scaleX: scaleX,
                            scaleY: scaleY,
                            naturalWidth: imageElement.naturalWidth,
                            naturalHeight: imageElement.naturalHeight,
                            rectWidth: rect.width,
                            rectHeight: rect.height
                        });
                        return;
                    }
                    
                    const offsetX = Math.round(x * scaleX);
                    const offsetY = Math.round(y * scaleY);
                    
                    console.log('[Snap Selector] T·ªça ƒë·ªô ƒë√£ t√≠nh:', {
                        displayX: x,
                        displayY: y,
                        scaleX: scaleX,
                        scaleY: scaleY,
                        offsetX: offsetX,
                        offsetY: offsetY
                    });

                    // T·ª± ƒë·ªông t·∫°o selection nh·ªè xung quanh ƒëi·ªÉm (20x20 pixel)
                    const selectionSize = 20;
                    const selectionX = Math.max(0, Math.round((x * scaleX) - selectionSize / 2));
                    const selectionY = Math.max(0, Math.round((y * scaleY) - selectionSize / 2));
                    const selectionWidth = Math.min(selectionSize, imageElement.naturalWidth - selectionX);
                    const selectionHeight = Math.min(selectionSize, imageElement.naturalHeight - selectionY);
                    
                    const autoSelection = {
                        x: selectionX,
                        y: selectionY,
                        width: selectionWidth,
                        height: selectionHeight
                    };
                    
                    // Th√™m c√°c selections hi·ªán t·∫°i v√†o ƒëi·ªÉm m·ªõi (n·∫øu c√≥)
                    const selections = currentSelections.length > 0 
                        ? currentSelections.map(s => {
                            const scaleX2 = imageElement.naturalWidth / rect.width;
                            const scaleY2 = imageElement.naturalHeight / rect.height;
                            return {
                                x: Math.round(s.x * scaleX2),
                                y: Math.round(s.y * scaleY2),
                                width: Math.round(s.width * scaleX2),
                                height: Math.round(s.height * scaleY2)
                            };
                        })
                        : [];
                    
                    // Th√™m auto selection v√†o ƒë·∫ßu m·∫£ng
                    selections.unshift(autoSelection);
                    
                    // Reset selections hi·ªán t·∫°i
                    currentSelections = [];
                    currentSelectionIndex = -1;
                    if (tempSelectionBox) {
                        tempSelectionBox.style.display = 'none';
                    }

                    addClickPoint(offsetX, offsetY, x, y, selections);
                } catch (error) {
                    console.error('[Snap Selector] L·ªói khi x·ª≠ l√Ω contextmenu:', error);
                }
            });

            // X·ª≠ l√Ω c√°c n√∫t
            document.getElementById('clearSelectionBtn').addEventListener('click', () => {
                currentSelections = [];
                currentSelectionIndex = -1;
                clearAllSelectionBoxes();
                updateSelectionInfo();
            });

            document.getElementById('clearPointsBtn').addEventListener('click', () => {
                clickPoints = [];
                renderClickPoints();
            });

            document.getElementById('clearAllBtn').addEventListener('click', () => {
                currentSelections = [];
                currentSelectionIndex = -1;
                clearAllSelectionBoxes();
                clickPoints = [];
                renderClickPoints();
                updateSelectionInfo();
            });

            document.getElementById('saveBtn').addEventListener('click', () => {
                // L∆∞u c√°c ƒëi·ªÉm v·ªõi selections c·ªßa ch√∫ng
                const points = clickPoints.map(p => ({
                    offsetX: p.offsetX,
                    offsetY: p.offsetY,
                    selections: p.selections || []
                }));
                
                ipcRenderer.send('snap-selector-save', {
                    points: points,
                    imagePath: currentImagePath
                });
            });

            // C·∫≠p nh·∫≠t scale khi resize
            window.addEventListener('resize', () => {
                updateImageScale();
                renderSelectionBoxes();
                renderClickPoints();
            });
        }

        function updateImageScale() {
            try {
                if (!imageElement) {
                    console.error('[Snap Selector] L·ªói: imageElement kh√¥ng t·ªìn t·∫°i trong updateImageScale');
                    return;
                }
                
                const rect = imageElement.getBoundingClientRect();
                
                if (rect.width === 0 || rect.height === 0) {
                    console.warn('[Snap Selector] C·∫£nh b√°o: K√≠ch th∆∞·ªõc rect = 0:', {
                        rectWidth: rect.width,
                        rectHeight: rect.height
                    });
                    return;
                }
                
                if (imageElement.naturalWidth === 0 || imageElement.naturalHeight === 0) {
                    console.warn('[Snap Selector] C·∫£nh b√°o: K√≠ch th∆∞·ªõc ·∫£nh t·ª± nhi√™n = 0:', {
                        naturalWidth: imageElement.naturalWidth,
                        naturalHeight: imageElement.naturalHeight
                    });
                    return;
                }
                
                imageScaleX = imageElement.naturalWidth / rect.width;
                imageScaleY = imageElement.naturalHeight / rect.height;
                imageOffsetX = rect.left;
                imageOffsetY = rect.top;
                
                console.log('[Snap Selector] ƒê√£ c·∫≠p nh·∫≠t scale:', {
                    scaleX: imageScaleX,
                    scaleY: imageScaleY,
                    offsetX: imageOffsetX,
                    offsetY: imageOffsetY
                });
            } catch (error) {
                console.error('[Snap Selector] L·ªói trong updateImageScale:', error);
            }
        }

        function addClickPoint(offsetX, offsetY, displayX, displayY, selections = []) {
            try {
                if (typeof offsetX !== 'number' || typeof offsetY !== 'number' || 
                    typeof displayX !== 'number' || typeof displayY !== 'number') {
                    console.error('[Snap Selector] L·ªói: T·ªça ƒë·ªô kh√¥ng h·ª£p l·ªá:', {
                        offsetX: offsetX,
                        offsetY: offsetY,
                        displayX: displayX,
                        displayY: displayY
                    });
                    return;
                }
                
                if (!imageWrapper) {
                    console.error('[Snap Selector] L·ªói: imageWrapper kh√¥ng t·ªìn t·∫°i');
                    return;
                }
                
                const point = {
                    offsetX,
                    offsetY,
                    displayX,
                    displayY,
                    selections: Array.isArray(selections) ? selections : [],
                    id: Date.now() + Math.random()
                };
                
                console.log('[Snap Selector] Th√™m ƒëi·ªÉm click:', point);
                clickPoints.push(point);
                renderClickPoints();
                renderSelectionBoxes();
            } catch (error) {
                console.error('[Snap Selector] L·ªói trong addClickPoint:', error);
            }
        }

        function renderClickPoints() {
            try {
                if (!imageWrapper) {
                    console.error('[Snap Selector] L·ªói: imageWrapper kh√¥ng t·ªìn t·∫°i trong renderClickPoints');
                    return;
                }
                
                // X√≥a t·∫•t c·∫£ ƒëi·ªÉm c≈©
                document.querySelectorAll('.click-point').forEach(el => el.remove());

                console.log('[Snap Selector] Render ƒëi·ªÉm click, s·ªë l∆∞·ª£ng:', clickPoints.length);

                // V·∫Ω ƒëi·ªÉm m·ªõi
                clickPoints.forEach((point, index) => {
                    try {
                        if (!point || typeof point.displayX !== 'number' || typeof point.displayY !== 'number') {
                            console.error('[Snap Selector] L·ªói: ƒêi·ªÉm kh√¥ng h·ª£p l·ªá t·∫°i index', index, point);
                            return;
                        }
                        
                        const pointEl = document.createElement('div');
                        pointEl.className = 'click-point';
                        pointEl.style.left = point.displayX + 'px';
                        pointEl.style.top = point.displayY + 'px';
                        pointEl.setAttribute('data-index', index + 1);
                        imageWrapper.appendChild(pointEl);
                    } catch (error) {
                        console.error('[Snap Selector] L·ªói khi render ƒëi·ªÉm t·∫°i index', index, ':', error);
                    }
                });

                updatePointsInfo();
            } catch (error) {
                console.error('[Snap Selector] L·ªói trong renderClickPoints:', error);
            }
        }

        function clearAllSelectionBoxes() {
            if (!imageWrapper) return;
            document.querySelectorAll('.selection-box:not(#tempSelectionBox)').forEach(box => {
                if (box !== tempSelectionBox) {
                    box.remove();
                }
            });
        }

        function renderSelectionBoxes() {
            if (!imageWrapper || !imageElement) return;
            
            // X√≥a t·∫•t c·∫£ selection boxes c≈© (tr·ª´ temp)
            clearAllSelectionBoxes();
            
            const rect = imageElement.getBoundingClientRect();
            const scaleX = rect.width / imageElement.naturalWidth;
            const scaleY = rect.height / imageElement.naturalHeight;
            
            // Render selections cho c√°c ƒëi·ªÉm ƒë√£ l∆∞u
            clickPoints.forEach((point, pointIndex) => {
                if (point.selections && Array.isArray(point.selections)) {
                    point.selections.forEach((sel, selIndex) => {
                        const box = document.createElement('div');
                        box.className = 'selection-box active';
                        box.style.left = (sel.x * scaleX) + 'px';
                        box.style.top = (sel.y * scaleY) + 'px';
                        box.style.width = (sel.width * scaleX) + 'px';
                        box.style.height = (sel.height * scaleY) + 'px';
                        box.setAttribute('data-point-index', pointIndex);
                        box.setAttribute('data-selection-index', selIndex);
                        imageWrapper.appendChild(box);
                    });
                }
            });
            
            // Render selections ƒëang ƒë∆∞·ª£c v·∫Ω (ch∆∞a l∆∞u)
            currentSelections.forEach((sel, index) => {
                if (index === currentSelectionIndex && tempSelectionBox) {
                    // ƒêang v·∫Ω, d√πng temp box
                    return;
                }
                const box = document.createElement('div');
                box.className = 'selection-box active';
                box.style.left = (sel.x * scaleX) + 'px';
                box.style.top = (sel.y * scaleY) + 'px';
                box.style.width = (sel.width * scaleX) + 'px';
                box.style.height = (sel.height * scaleY) + 'px';
                box.setAttribute('data-temp-index', index);
                imageWrapper.appendChild(box);
            });
        }

        function updateSelectionInfo() {
            const infoEl = document.getElementById('selectionInfo');
            const totalSelections = clickPoints.reduce((sum, p) => sum + (p.selections?.length || 0), 0) + currentSelections.length;
            if (totalSelections > 0) {
                infoEl.textContent = `${totalSelections} khu v·ª±c so s√°nh`;
            } else {
                infoEl.textContent = 'Ch∆∞a ch·ªçn khu v·ª±c';
            }
        }

        function updatePointsInfo() {
            const infoEl = document.getElementById('pointsInfo');
            infoEl.textContent = `${clickPoints.length} ƒëi·ªÉm click`;
        }

        // Kh·ªüi t·∫°o khi DOM ready
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', init);
        } else {
            init();
        }
    </script>
</body>
</html>

