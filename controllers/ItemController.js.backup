const { spawn, exec } = require('child_process');
const path = require('path');
const fs = require('fs');

class ItemController {
  constructor(dataModel, ipcMain, mainWindow, appDir) {
    this.dataModel = dataModel;
    this.mainWindow = mainWindow;
    this.appDir = appDir;
    this.flashProcess = null;
    this.flashProcessesByTen = {}; // Lưu PID theo tên định danh
    this.autoClickProcess = null;
    this.autoClickScriptPath = null;
    this.autoClickTarget = null;
    this.autoClickProcesses = {}; // Lưu auto process cho từng item: { itemId: { process, scriptPath, targetWindow } }
    this.autoConfigPath = path.join(this.appDir, 'auto-config.json');
    this.autoClickConfig = this.loadAutoClickConfig();
    this.autoProfilesPath = path.join(this.appDir, 'auto-profiles.json');
    this.autoProfiles = this.loadAutoProfilesFromDisk();
    this.recordClickProcess = null;
    this.recordClickScriptPath = null;
    this.recordClickTarget = null;
    this.setupIPC(ipcMain);
  }

  setupIPC(ipcMain) {
    ipcMain.handle('get-data', () => {
      return this.dataModel.getAll();
    });

    ipcMain.handle('add-item', (event, item) => {
      return this.dataModel.add(item);
    });

    ipcMain.handle('update-item', (event, id, updates) => {
      return this.dataModel.update(id, updates);
    });

    ipcMain.handle('delete-item', (event, id) => {
      return this.dataModel.delete(id);
    });

    ipcMain.handle('update-window-title', (event, title) => {
      if (this.mainWindow) {
        this.mainWindow.setTitle(title);
      }
    });

    ipcMain.handle('play-flash', (event, url, ten) => {
      this.openFlashPlayer(url, ten);
    });

    ipcMain.handle('auto-load-config', () => this.autoClickConfig);
    ipcMain.handle('auto-save-config', (event, partialConfig) => this.saveAutoClickConfig(partialConfig || {}));
    ipcMain.handle('auto-list-profiles', () => this.autoProfiles);
    ipcMain.handle('auto-save-profile', (event, profile) => this.saveAutoProfile(profile || {}));
    ipcMain.handle('auto-delete-profile', (event, profileName) => this.deleteAutoProfile(profileName));
    ipcMain.handle('auto-target-by-title', async (event, title) => this.detectAutoWindowByTitle(title));
    ipcMain.handle('auto-target-by-pid', async (event, pid) => this.detectAutoWindowByPid(pid));
    ipcMain.handle('get-flash-pid-by-ten', (event, ten) => {
      return this.flashProcessesByTen[ten] || null;
    });
    ipcMain.handle('find-pid-by-title', async (event, title) => this.findPidByTitle(title));

    ipcMain.handle('auto-detect-window', async (event, coords) => {
      return await this.detectAutoClickWindow(coords);
    });

    ipcMain.handle('auto-compute-point', async (event, coords) => {
      return await this.computeAutoClickPoint(coords);
    });

    ipcMain.handle('auto-start', async (event, config) => {
      return await this.startAutoClick(config);
    });
    ipcMain.handle('auto-start-for-item', async (event, itemId, config) => {
      return await this.startAutoClickForItem(itemId, config);
    });
    ipcMain.handle('auto-stop-for-item', async (event, itemId) => {
      return await this.stopAutoClickForItem(itemId);
    });

    ipcMain.handle('auto-stop', async () => {
      return await this.stopAutoClick();
    });

    ipcMain.handle('record-click-start', async (event, config) => {
      return await this.startRecordClick(config);
    });

    ipcMain.handle('record-click-stop', async () => {
      return await this.stopRecordClick();
    });
  }

  openFlashPlayer(url, ten = null) {
    const flashExePath = path.join(this.appDir, 'flash.exe');
    
    // Kiểm tra xem file flash.exe có tồn tại không
    if (!fs.existsSync(flashExePath)) {
      console.error('Không tìm thấy file flash.exe');
      if (this.mainWindow) {
        this.mainWindow.webContents.send('flash-error', 'Không tìm thấy file flash.exe');
      }
      return;
    }

    // Lưu tên định danh vào biến local để dùng trong callback
    const tenDinhDanh = ten;

    // Chạy Flash Player với URL
    this.flashProcess = spawn(flashExePath, [url], {
      cwd: this.appDir,
      detached: true,
      stdio: 'ignore'
    });

    this.flashProcess.on('error', (error) => {
      console.error('Lỗi khi chạy Flash Player:', error);
      if (this.mainWindow) {
        this.mainWindow.webContents.send('flash-error', error.message);
      }
    });

    const processPid = this.flashProcess.pid;

    this.flashProcess.on('exit', (code) => {
      console.log(`Flash Player đã đóng với mã: ${code}`);
      // Xóa PID khỏi danh sách khi process đóng
      if (tenDinhDanh && this.flashProcessesByTen[tenDinhDanh] === processPid) {
        delete this.flashProcessesByTen[tenDinhDanh];
        console.log(`Đã xóa PID ${processPid} khỏi danh sách cho tên định danh: ${tenDinhDanh}`);
      }
      this.flashProcess = null;
    });

    // Cho phép Flash Player chạy độc lập
    this.flashProcess.unref();

    // Lưu PID theo tên định danh
    if (tenDinhDanh && processPid) {
      this.flashProcessesByTen[tenDinhDanh] = processPid;
      console.log(`Đã lưu PID ${processPid} cho tên định danh: ${tenDinhDanh}`);
    }

    // Thay đổi tiêu đề cửa sổ Flash Player ngay khi mở (thử nhiều lần với interval ngắn)
    if (tenDinhDanh) {
      // Thử đổi tên ngay sau một khoảng thời gian ngắn
      setTimeout(() => {
        this.changeFlashWindowTitleImmediately(tenDinhDanh);
      }, 100);
    }
  }

  changeFlashWindowTitleImmediately(newTitle) {
    const processId = this.flashProcess ? this.flashProcess.pid : null;
    
    if (!processId) {
      console.log('Không tìm thấy process ID của Flash Player');
      return;
    }

    // Thử đổi tên ngay với interval ngắn hơn và nhiều lần thử hơn để đổi tên nhanh nhất
    let attempts = 0;
    const maxAttempts = 30; // Tối đa 1.5 giây (30 * 50ms)
    const interval = 50; // Kiểm tra mỗi 50ms để nhanh hơn

    const tryChangeTitle = () => {
      attempts++;
      
      if (attempts > maxAttempts) {
        console.log('Không tìm thấy cửa sổ Flash Player sau nhiều lần thử');
        return;
      }

      // Kiểm tra xem process còn chạy không
      try {
        process.kill(processId, 0); // Signal 0 chỉ kiểm tra, không kill
      } catch (e) {
        // Process đã đóng
        return;
      }

      this.changeFlashWindowTitle(newTitle, processId, (success) => {
        if (!success && attempts < maxAttempts) {
          // Nếu chưa thành công và chưa hết số lần thử, thử lại
          setTimeout(tryChangeTitle, interval);
        } else if (success) {
          console.log('Đã thay đổi tiêu đề cửa sổ Flash Player thành:', newTitle);
        }
      });
    };

    // Bắt đầu thử ngay lập tức
    tryChangeTitle();
  }

  changeFlashWindowTitle(newTitle, processId, callback) {
    if (!processId) {
      processId = this.flashProcess ? this.flashProcess.pid : null;
    }
    
    if (!processId) {
      if (callback) callback(false);
      return;
    }

    // Tạo PowerShell script để thay đổi tiêu đề cửa sổ
    const scriptPath = path.join(this.appDir, 'changeWindowTitle.ps1');
    const escapedTitle = newTitle.replace(/"/g, '`"').replace(/\$/g, '`$');
    
    const powershellScript = `Add-Type @"
using System;
using System.Runtime.InteropServices;
public class Win32 {
  [DllImport("user32.dll")]
  public static extern bool EnumWindows(EnumWindowsProc enumProc, IntPtr lParam);
  [DllImport("user32.dll")]
  public static extern int GetWindowText(IntPtr hWnd, System.Text.StringBuilder lpString, int nMaxCount);
  [DllImport("user32.dll")]
  public static extern int GetWindowTextLength(IntPtr hWnd);
  [DllImport("user32.dll")]
  public static extern bool SetWindowText(IntPtr hWnd, string lpString);
  [DllImport("user32.dll")]
  public static extern uint GetWindowThreadProcessId(IntPtr hWnd, out uint lpdwProcessId);
  public delegate bool EnumWindowsProc(IntPtr hWnd, IntPtr lParam);
}
"@
$processId = ${processId}
$newTitle = "${escapedTitle}"
$found = $false
[Win32]::EnumWindows({
  param($hWnd, $lParam)
  $length = [Win32]::GetWindowTextLength($hWnd)
  if ($length -gt 0) {
    $sb = New-Object System.Text.StringBuilder($length + 1)
    [Win32]::GetWindowText($hWnd, $sb, $sb.Capacity) | Out-Null
    $windowTitle = $sb.ToString()
    $windowPid = 0
    [Win32]::GetWindowThreadProcessId($hWnd, [ref]$windowPid) | Out-Null
    if ($windowTitle -like "*Adobe Flash Player*" -and $windowPid -eq $processId) {
      [Win32]::SetWindowText($hWnd, $newTitle) | Out-Null
      $found = $true
      return $false
    }
  }
  return $true
}, 0) | Out-Null
if ($found) { Write-Output "SUCCESS" } else { Write-Output "NOTFOUND" }`;

    // Ghi script vào file tạm
    fs.writeFileSync(scriptPath, powershellScript, 'utf8');

    // Chạy PowerShell script
    exec(`powershell -ExecutionPolicy Bypass -File "${scriptPath}"`, (error, stdout, stderr) => {
      // Xóa file script tạm
      try {
        if (fs.existsSync(scriptPath)) {
          fs.unlinkSync(scriptPath);
        }
      } catch (e) {
        // Bỏ qua lỗi xóa file
      }
      
      const success = stdout && stdout.toString().trim() === 'SUCCESS';
      if (callback) {
        callback(success);
      } else if (success) {
        console.log('Đã thay đổi tiêu đề cửa sổ Flash Player thành:', newTitle);
      }
    });
  }


  async detectAutoClickWindow(coords = {}) {
    const { x, y } = coords;
    if (typeof x !== 'number' || typeof y !== 'number') {
      return { success: false, error: 'Tọa độ không hợp lệ.' };
    }

    const pointX = Math.round(x);
    const pointY = Math.round(y);

    const scriptContent = `Add-Type @"
using System;
using System.Runtime.InteropServices;
public class AutoWindowFinder {
  [DllImport("user32.dll")]
  public static extern IntPtr WindowFromPoint(POINT Point);
  [DllImport("user32.dll")]
  public static extern IntPtr GetAncestor(IntPtr hWnd, uint gaFlags);
  [DllImport("user32.dll")]
  public static extern int GetWindowText(IntPtr hWnd, System.Text.StringBuilder lpString, int nMaxCount);
  [DllImport("user32.dll")]
  public static extern int GetWindowTextLength(IntPtr hWnd);
  [DllImport("user32.dll")]
  public static extern uint GetWindowThreadProcessId(IntPtr hWnd, out uint processId);
  public struct POINT {
    public int X;
    public int Y;
  }
}
"@
$point = New-Object AutoWindowFinder+POINT
$point.X = ${pointX}
$point.Y = ${pointY}
$handle = [AutoWindowFinder]::WindowFromPoint($point)
if ($handle -eq [IntPtr]::Zero) {
  Write-Output "NOTFOUND"
  exit
}
$GA_ROOT = 2
$root = [AutoWindowFinder]::GetAncestor($handle, $GA_ROOT)
if ($root -ne [IntPtr]::Zero) {
  $handle = $root
}
$pid = 0
[AutoWindowFinder]::GetWindowThreadProcessId($handle, [ref]$pid) | Out-Null
$length = [AutoWindowFinder]::GetWindowTextLength($handle)
if ($length -le 0) {
  $title = "Ứng dụng không tên"
} else {
  $sb = New-Object System.Text.StringBuilder($length + 1)
  [AutoWindowFinder]::GetWindowText($handle, $sb, $sb.Capacity) | Out-Null
  $title = $sb.ToString()
}
$result = [PSCustomObject]@{
  pid = $pid
  title = $title
  handle = $handle.ToInt64()
}
$result | ConvertTo-Json -Compress`;

    const scriptPath = this.writeTempScript('detectWindow', scriptContent);

    return await new Promise((resolve) => {
      exec(`powershell -ExecutionPolicy Bypass -File "${scriptPath}"`, (error, stdout, stderr) => {
        this.cleanupTempScript(scriptPath);

        if (error) {
          console.error('Lỗi khi xác định ứng dụng:', stderr || error.message);
          resolve({ success: false, error: 'Không xác định được ứng dụng.' });
          return;
        }

        const output = stdout ? stdout.toString().trim() : '';
        if (!output || output === 'NOTFOUND') {
          resolve({ success: false, error: 'Không tìm thấy cửa sổ ở vị trí đã thả.' });
          return;
        }

        let parsed;
        try {
          parsed = JSON.parse(output);
        } catch (e) {
          console.error('Không parse được JSON trả về:', output);
          resolve({ success: false, error: 'Dữ liệu trả về không hợp lệ.' });
          return;
        }

        this.autoClickTarget = {
          pid: parsed.pid,
          title: parsed.title,
          handle: Number(parsed.handle) || parsed.handle
        };

        resolve({
          success: true,
          window: this.autoClickTarget
        });
      });
    });
  }

  async detectAutoWindowByTitle(title) {
    const keyword = (title || '').trim();
    if (!keyword) {
      return { success: false, error: 'Thiếu tên định danh để tìm ứng dụng.' };
    }

    const escapedTitle = keyword.replace(/"/g, '`"').replace(/\$/g, '`$');

    const scriptContent = `Add-Type @"
using System;
using System.Runtime.InteropServices;
public class AutoWindowFinderByTitle {
  [DllImport("user32.dll")]
  public static extern bool EnumWindows(EnumWindowsProc enumProc, IntPtr lParam);
  [DllImport("user32.dll")]
  public static extern int GetWindowText(IntPtr hWnd, System.Text.StringBuilder lpString, int nMaxCount);
  [DllImport("user32.dll")]
  public static extern int GetWindowTextLength(IntPtr hWnd);
  [DllImport("user32.dll")]
  public static extern uint GetWindowThreadProcessId(IntPtr hWnd, out uint processId);
  public delegate bool EnumWindowsProc(IntPtr hWnd, IntPtr lParam);
}
"@
$keyword = "${escapedTitle}"
$foundWindow = $null
[AutoWindowFinderByTitle]::EnumWindows({
  param($hWnd, $lParam)
  $length = [AutoWindowFinderByTitle]::GetWindowTextLength($hWnd)
  if ($length -gt 0) {
    $sb = New-Object System.Text.StringBuilder($length + 1)
    [AutoWindowFinderByTitle]::GetWindowText($hWnd, $sb, $sb.Capacity) | Out-Null
    $windowTitle = $sb.ToString()
    if ($windowTitle -like "*$keyword*") {
      $pid = 0
      [AutoWindowFinderByTitle]::GetWindowThreadProcessId($hWnd, [ref]$pid) | Out-Null
      $foundWindow = [PSCustomObject]@{
        pid = $pid
        title = $windowTitle
        handle = $hWnd.ToInt64()
      }
      return $false
    }
  }
  return $true
}, 0) | Out-Null
if ($foundWindow) { $foundWindow | ConvertTo-Json -Compress } else { Write-Output "NOTFOUND" }`;

    const scriptPath = this.writeTempScript('autoFindByTitle', scriptContent);

    return await new Promise((resolve) => {
      exec(`powershell -ExecutionPolicy Bypass -File "${scriptPath}"`, (error, stdout, stderr) => {
        this.cleanupTempScript(scriptPath);

        if (error) {
          console.error('Lỗi khi tìm ứng dụng theo tên:', stderr || error.message);
          resolve({ success: false, error: 'Không tìm được ứng dụng theo tên.' });
          return;
        }

        const output = stdout ? stdout.toString().trim() : '';
        if (!output || output === 'NOTFOUND') {
          resolve({ success: false, error: 'Không tìm thấy cửa sổ trùng tên.' });
          return;
        }

        try {
          const parsed = JSON.parse(output);
          this.autoClickTarget = {
            pid: parsed.pid,
            title: parsed.title,
            handle: Number(parsed.handle) || parsed.handle
          };

          resolve({
            success: true,
            window: this.autoClickTarget
          });
        } catch (err) {
          console.error('Không parse được kết quả tìm cửa sổ:', output);
          resolve({ success: false, error: 'Dữ liệu trả về không hợp lệ.' });
        }
      });
    });
  }

  async detectAutoWindowByPid(pid) {
    const processId = Number(pid);
    if (!processId || !Number.isInteger(processId) || processId <= 0) {
      return { success: false, error: 'PID không hợp lệ.' };
    }

    const scriptContent = `Add-Type @"
using System;
using System.Runtime.InteropServices;
public class AutoWindowFinderByPid {
  [DllImport("user32.dll")]
  public static extern bool EnumWindows(EnumWindowsProc enumProc, IntPtr lParam);
  [DllImport("user32.dll")]
  public static extern int GetWindowText(IntPtr hWnd, System.Text.StringBuilder lpString, int nMaxCount);
  [DllImport("user32.dll")]
  public static extern int GetWindowTextLength(IntPtr hWnd);
  [DllImport("user32.dll")]
  public static extern uint GetWindowThreadProcessId(IntPtr hWnd, out uint processId);
  public delegate bool EnumWindowsProc(IntPtr hWnd, IntPtr lParam);
}
"@
$targetPid = ${processId}
$foundWindow = $null
[AutoWindowFinderByPid]::EnumWindows({
  param($hWnd, $lParam)
  $windowPid = 0
  [AutoWindowFinderByPid]::GetWindowThreadProcessId($hWnd, [ref]$windowPid) | Out-Null
  if ($windowPid -eq $targetPid) {
    $length = [AutoWindowFinderByPid]::GetWindowTextLength($hWnd)
    $title = ""
    if ($length -gt 0) {
      $sb = New-Object System.Text.StringBuilder($length + 1)
      [AutoWindowFinderByPid]::GetWindowText($hWnd, $sb, $sb.Capacity) | Out-Null
      $title = $sb.ToString()
    }
    $foundWindow = [PSCustomObject]@{
      pid = $windowPid
      title = $title
      handle = $hWnd.ToInt64()
    }
    return $false
  }
  return $true
}, 0) | Out-Null
if ($foundWindow) { $foundWindow | ConvertTo-Json -Compress } else { Write-Output "NOTFOUND" }`;

    const scriptPath = this.writeTempScript('autoFindByPid', scriptContent);

    return await new Promise((resolve) => {
      exec(`powershell -ExecutionPolicy Bypass -File "${scriptPath}"`, (error, stdout, stderr) => {
        this.cleanupTempScript(scriptPath);

        if (error) {
          console.error('Lỗi khi tìm ứng dụng theo PID:', stderr || error.message);
          resolve({ success: false, error: 'Không tìm được ứng dụng theo PID.' });
          return;
        }

        const output = stdout ? stdout.toString().trim() : '';
        if (!output || output === 'NOTFOUND') {
          resolve({ success: false, error: 'Không tìm thấy cửa sổ với PID này.' });
          return;
        }

        try {
          const parsed = JSON.parse(output);
          this.autoClickTarget = {
            pid: parsed.pid,
            title: parsed.title,
            handle: Number(parsed.handle) || parsed.handle
          };

          resolve({
            success: true,
            window: this.autoClickTarget
          });
        } catch (err) {
          console.error('Không parse được kết quả tìm cửa sổ theo PID:', output);
          resolve({ success: false, error: 'Dữ liệu trả về không hợp lệ.' });
        }
      });
    });
  }

  async findPidByTitle(title) {
    const keyword = (title || '').trim();
    if (!keyword) {
      return { success: false, error: 'Thiếu tên định danh để tìm PID.' };
    }

    const escapedTitle = keyword.replace(/"/g, '`"').replace(/\$/g, '`$');
    
    // Sử dụng PowerShell command để tìm PID theo MainWindowTitle
    const powershellCommand = `Get-Process | Where-Object { $_.MainWindowTitle -like "*${escapedTitle}*" } | Select-Object -First 1 Id, ProcessName, MainWindowTitle | ConvertTo-Json -Compress`;

    return await new Promise((resolve) => {
      exec(`powershell -ExecutionPolicy Bypass -Command "${powershellCommand}"`, (error, stdout, stderr) => {
        if (error) {
          console.error('Lỗi khi tìm PID theo tên:', stderr || error.message);
          resolve({ success: false, error: 'Không tìm được PID theo tên.' });
          return;
        }

        const output = stdout ? stdout.toString().trim() : '';
        if (!output) {
          resolve({ success: false, error: 'Không tìm thấy process với tên định danh này.' });
          return;
        }

        try {
          const parsed = JSON.parse(output);
          if (parsed && parsed.Id) {
            resolve({
              success: true,
              pid: parsed.Id,
              processName: parsed.ProcessName,
              windowTitle: parsed.MainWindowTitle
            });
          } else {
            resolve({ success: false, error: 'Không tìm thấy PID hợp lệ.' });
          }
        } catch (err) {
          console.error('Không parse được kết quả tìm PID:', output);
          resolve({ success: false, error: 'Dữ liệu trả về không hợp lệ.' });
        }
      });
    });
  }

  async computeAutoClickPoint(coords = {}) {
    const { x, y } = coords;
    if (!this.autoClickTarget || typeof x !== 'number' || typeof y !== 'number') {
      return { success: false, error: 'Thiếu thông tin ứng dụng hoặc tọa độ.' };
    }

    const screenX = Math.round(x);
    const screenY = Math.round(y);
    const handleValue = this.autoClickTarget.handle;

    const scriptContent = `Add-Type @"
using System;
using System.Runtime.InteropServices;
public class AutoPointResolver {
  [DllImport("user32.dll")]
  public static extern bool GetWindowRect(IntPtr hWnd, out RECT lpRect);
  public struct RECT {
    public int Left;
    public int Top;
    public int Right;
    public int Bottom;
  }
}
"@
$handle = [IntPtr]${handleValue}
$rect = New-Object AutoPointResolver+RECT
if (-not [AutoPointResolver]::GetWindowRect($handle, [ref]$rect)) {
  Write-Output "NOTFOUND"
  exit
}
$offsetX = ${screenX} - $rect.Left
$offsetY = ${screenY} - $rect.Top
if ($offsetX -lt 0 -or $offsetY -lt 0) {
  Write-Output "OUTSIDE"
  exit
}
$point = [PSCustomObject]@{
  offsetX = $offsetX
  offsetY = $offsetY
  screenX = ${screenX}
  screenY = ${screenY}
}
$point | ConvertTo-Json -Compress`;

    const scriptPath = this.writeTempScript('resolvePoint', scriptContent);

    return await new Promise((resolve) => {
      exec(`powershell -ExecutionPolicy Bypass -File "${scriptPath}"`, (error, stdout, stderr) => {
        this.cleanupTempScript(scriptPath);

        if (error) {
          console.error('Lỗi khi tính điểm auto:', stderr || error.message);
          resolve({ success: false, error: 'Không xác định được điểm auto.' });
          return;
        }

        const output = stdout ? stdout.toString().trim() : '';
        if (!output || output === 'NOTFOUND') {
          resolve({ success: false, error: 'Không lấy được kích thước cửa sổ.' });
          return;
        }

        if (output === 'OUTSIDE') {
          resolve({ success: false, error: 'Điểm thả nằm ngoài cửa sổ.' });
          return;
        }

        try {
          const point = JSON.parse(output);
          resolve({ success: true, point });
        } catch (e) {
          console.error('Không parse được JSON điểm auto:', output);
          resolve({ success: false, error: 'Dữ liệu điểm không hợp lệ.' });
        }
      });
    });
  }

  async startAutoClick(config = {}) {
    if (!this.autoClickTarget || !this.autoClickTarget.handle) {
      return { success: false, error: 'Vui lòng chọn ứng dụng trước khi chạy auto.' };
    }

    const points = Array.isArray(config.points) ? config.points : [];
    if (points.length === 0) {
      return { success: false, error: 'Chưa có điểm auto nào.' };
    }

    const sanitizedPoints = this.normalizeAutoPoints(points);

    if (sanitizedPoints.length === 0) {
      return { success: false, error: 'Điểm auto không hợp lệ.' };
    }

    const interval = Math.max(200, Number(config.interval) || 1000);

    // Dừng tiến trình hiện tại (nếu có)
    await this.stopAutoClick({ silent: true });

    const pointsJson = JSON.stringify(sanitizedPoints)
      .replace(/"/g, '`"')
      .replace(/\$/g, '`$');
    const scriptContent = this.buildAutoClickScript(this.autoClickTarget.handle, interval, pointsJson);
    const scriptPath = this.writeTempScript('autoClickRunner', scriptContent);
    this.autoClickScriptPath = scriptPath;
    this.saveAutoClickConfig({
      points: sanitizedPoints,
      interval
    });

    return await new Promise((resolve) => {
      this.autoClickProcess = spawn('powershell', ['-ExecutionPolicy', 'Bypass', '-File', scriptPath], {
        cwd: this.appDir,
        windowsHide: true
      });

      this.autoClickProcess.stdout.on('data', (data) => {
        const message = data.toString().trim();
        if (!message) return;

        if (message === 'TARGET_LOST') {
          this.autoClickTarget = null;
          if (this.mainWindow) {
            this.mainWindow.webContents.send('auto-click-status', {
              running: false,
              message: 'Cửa sổ mục tiêu đã đóng hoặc không còn hợp lệ.',
              type: 'error',
              targetLost: true
            });
          }
          this.stopAutoClick({ silent: true });
        }
      });

      this.autoClickProcess.stderr.on('data', (data) => {
        console.error('Auto click stderr:', data.toString());
      });

      this.autoClickProcess.on('exit', (code) => {
        this.cleanupAutoClickProcess();
        if (this.mainWindow) {
          this.mainWindow.webContents.send('auto-click-status', {
            running: false,
            message: code === 0 ? 'Auto click đã dừng.' : 'Auto click dừng đột ngột.',
            type: code === 0 ? 'success' : 'error'
          });
        }
      });

      resolve({ success: true });
    });
  }

  buildAutoClickScript(handleValue, interval, pointsJson) {
    return `Add-Type @"
using System;
using System.Runtime.InteropServices;
public class AutoClicker {
  [DllImport("user32.dll")]
  public static extern bool GetWindowRect(IntPtr hWnd, out RECT lpRect);
  [DllImport("user32.dll")]
  public static extern bool IsWindow(IntPtr hWnd);
  [DllImport("user32.dll")]
  public static extern bool ScreenToClient(IntPtr hWnd, ref POINT lpPoint);
  [DllImport("user32.dll")]
  public static extern IntPtr PostMessage(IntPtr hWnd, uint Msg, IntPtr wParam, IntPtr lParam);
  public struct RECT {
    public int Left;
    public int Top;
    public int Right;
    public int Bottom;
  }
  public struct POINT {
    public int X;
    public int Y;
  }
}
"@
$handle = [IntPtr]${handleValue}
$points = ConvertFrom-Json "${pointsJson}"
if ($points.Count -eq 0) {
  Write-Output "NOPTS"
  exit
}
$loopInterval = ${interval}
$WM_LBUTTONDOWN = 0x0201
$WM_LBUTTONUP = 0x0202
while ($true) {
  if (-not [AutoClicker]::IsWindow($handle)) {
    Write-Output "TARGET_LOST"
    break
  }
  $rect = New-Object AutoClicker+RECT
  if (-not [AutoClicker]::GetWindowRect($handle, [ref]$rect)) {
    Start-Sleep -Milliseconds 300
    continue
  }
  foreach ($point in $points) {
    $screenPoint = New-Object AutoClicker+POINT
    $screenPoint.X = [int]($rect.Left + $point.offsetX)
    $screenPoint.Y = [int]($rect.Top + $point.offsetY)
    $clientPoint = $screenPoint
    [AutoClicker]::ScreenToClient($handle, [ref]$clientPoint) | Out-Null
    $clientX = $clientPoint.X
    $clientY = $clientPoint.Y
    if ($clientX -lt 0 -or $clientY -lt 0) {
      continue
    }
    $lParam = ($clientY -band 0xFFFF) -shl 16 -bor ($clientX -band 0xFFFF)
    [AutoClicker]::PostMessage($handle, $WM_LBUTTONDOWN, [IntPtr]1, [IntPtr]$lParam) | Out-Null
    Start-Sleep -Milliseconds 40
    [AutoClicker]::PostMessage($handle, $WM_LBUTTONUP, [IntPtr]0, [IntPtr]$lParam) | Out-Null
    Start-Sleep -Milliseconds 80
  }
  Start-Sleep -Milliseconds $loopInterval
}`;
  }

  async stopAutoClick(options = {}) {
    const silent = options && options.silent;
    if (this.autoClickProcess) {
      try {
        this.autoClickProcess.kill();
      } catch (error) {
        console.error('Không thể dừng auto click:', error);
      }
    }

    this.cleanupAutoClickProcess();

    if (!silent && this.mainWindow) {
      this.mainWindow.webContents.send('auto-click-status', {
        running: false,
        message: 'Auto click đã dừng.',
        type: 'success'
      });
    }

    return { success: true };
  }

  async startAutoClickForItem(itemId, config = {}) {
    if (!config.targetWindow || !config.targetWindow.handle) {
      return { success: false, error: 'Thiếu thông tin cửa sổ đích.' };
    }

    const points = Array.isArray(config.points) ? config.points : [];
    if (points.length === 0) {
      return { success: false, error: 'Chưa có điểm auto nào.' };
    }

    const sanitizedPoints = this.normalizeAutoPoints(points);
    if (sanitizedPoints.length === 0) {
      return { success: false, error: 'Điểm auto không hợp lệ.' };
    }

    const interval = Math.max(200, Number(config.interval) || 1000);

    // Dừng auto cũ của item này nếu có
    await this.stopAutoClickForItem(itemId, { silent: true });

    const pointsJson = JSON.stringify(sanitizedPoints)
      .replace(/"/g, '`"')
      .replace(/\$/g, '`$');
    const scriptContent = this.buildAutoClickScript(config.targetWindow.handle, interval, pointsJson);
    const scriptPath = this.writeTempScript(`autoClickRunner-${itemId}`, scriptContent);

    return await new Promise((resolve) => {
      const process = spawn('powershell', ['-ExecutionPolicy', 'Bypass', '-File', scriptPath], {
        cwd: this.appDir,
        windowsHide: true
      });

      // Lưu thông tin process cho item này
      this.autoClickProcesses[itemId] = {
        process,
        scriptPath,
        targetWindow: config.targetWindow
      };

      process.stdout.on('data', (data) => {
        const message = data.toString().trim();
        if (!message) return;

        if (message === 'TARGET_LOST') {
          if (this.mainWindow) {
            this.mainWindow.webContents.send('auto-click-status-for-item', {
              itemId,
              running: false,
              message: 'Cửa sổ mục tiêu đã đóng hoặc không còn hợp lệ.',
              type: 'error',
              targetLost: true
            });
          }
          this.stopAutoClickForItem(itemId, { silent: true });
        }
      });

      process.stderr.on('data', (data) => {
        console.error(`Auto click stderr cho item ${itemId}:`, data.toString());
      });

      process.on('exit', (code) => {
        this.cleanupAutoClickProcessForItem(itemId);
        if (this.mainWindow) {
          this.mainWindow.webContents.send('auto-click-status-for-item', {
            itemId,
            running: false,
            message: code === 0 ? 'Auto click đã dừng.' : 'Auto click dừng đột ngột.',
            type: code === 0 ? 'success' : 'error'
          });
        }
      });

      resolve({ success: true });
    });
  }

  async stopAutoClickForItem(itemId, options = {}) {
    const silent = options && options.silent;
    const itemProcess = this.autoClickProcesses[itemId];
    
    if (!itemProcess) {
      // Nếu không có process, vẫn trả về success để cập nhật UI
      if (!silent && this.mainWindow) {
        this.mainWindow.webContents.send('auto-click-status-for-item', {
          itemId,
          running: false,
          message: 'Auto click đã dừng.',
          type: 'success'
        });
      }
      return { success: true };
    }
    
    if (itemProcess.process) {
      try {
        itemProcess.process.kill();
        console.log(`Đã kill process cho item ${itemId}`);
      } catch (error) {
        console.error(`Không thể dừng auto click cho item ${itemId}:`, error);
      }
    }

    this.cleanupAutoClickProcessForItem(itemId);

    if (!silent && this.mainWindow) {
      this.mainWindow.webContents.send('auto-click-status-for-item', {
        itemId,
        running: false,
        message: 'Auto click đã dừng.',
        type: 'success'
      });
    }

    return { success: true };
  }

  cleanupAutoClickProcessForItem(itemId) {
    const itemProcess = this.autoClickProcesses[itemId];
    if (itemProcess) {
      if (itemProcess.process) {
        itemProcess.process.removeAllListeners();
      }
      if (itemProcess.scriptPath) {
        this.cleanupTempScript(itemProcess.scriptPath);
      }
      delete this.autoClickProcesses[itemId];
    }
  }

  cleanupAutoClickProcess() {
    if (this.autoClickProcess) {
      this.autoClickProcess.removeAllListeners();
      this.autoClickProcess = null;
    }

    this.cleanupTempScript(this.autoClickScriptPath);
    this.autoClickScriptPath = null;
  }

  loadAutoProfilesFromDisk() {
    try {
      if (fs.existsSync(this.autoProfilesPath)) {
        const raw = fs.readFileSync(this.autoProfilesPath, 'utf8');
        const parsed = JSON.parse(raw);
        if (Array.isArray(parsed)) {
          return parsed
            .map((profile) => this.normalizeAutoProfile(profile))
            .filter(Boolean);
        }
      }
    } catch (error) {
      console.warn('Không thể đọc danh sách quy trình auto:', error.message);
    }
    return [];
  }

  normalizeAutoProfile(profile) {
    if (!profile || typeof profile.name !== 'string') {
      return null;
    }
    const name = profile.name.trim();
    if (!name) {
      return null;
    }
    const points = this.normalizeAutoPoints(profile.points || []);
    if (!points.length) {
      return null;
    }
    return {
      name,
      interval: Math.max(200, Number(profile.interval) || 1200),
      points
    };
  }

  persistAutoProfiles() {
    try {
      fs.writeFileSync(this.autoProfilesPath, JSON.stringify(this.autoProfiles, null, 2), 'utf8');
    } catch (error) {
      console.error('Không thể lưu danh sách quy trình auto:', error.message);
    }
  }

  saveAutoProfile(payload = {}) {
    const name = (payload.name || '').trim();
    if (!name) {
      return { success: false, error: 'Tên quy trình không hợp lệ.' };
    }
    const points = this.normalizeAutoPoints(payload.points || []);
    if (!points.length) {
      return { success: false, error: 'Quy trình cần ít nhất một điểm auto.' };
    }
    const interval = Math.max(200, Number(payload.interval) || 1000);
    const profile = { name, interval, points };

    const existingIndex = this.autoProfiles.findIndex(
      (item) => item.name.toLowerCase() === name.toLowerCase()
    );

    if (existingIndex >= 0) {
      this.autoProfiles[existingIndex] = profile;
    } else {
      this.autoProfiles.push(profile);
    }

    this.persistAutoProfiles();
    return { success: true, profiles: this.autoProfiles };
  }

  deleteAutoProfile(profileName) {
    if (!profileName) {
      return { success: false, error: 'Thiếu tên quy trình.' };
    }

    const before = this.autoProfiles.length;
    this.autoProfiles = this.autoProfiles.filter(
      (profile) => profile.name.toLowerCase() !== String(profileName).toLowerCase()
    );

    if (this.autoProfiles.length === before) {
      return { success: false, error: 'Không tìm thấy quy trình cần xóa.' };
    }

    this.persistAutoProfiles();
    return { success: true, profiles: this.autoProfiles };
  }

  loadAutoClickConfig() {
    try {
      if (fs.existsSync(this.autoConfigPath)) {
        const raw = fs.readFileSync(this.autoConfigPath, 'utf8');
        const parsed = JSON.parse(raw);
        return {
          interval: Number(parsed.interval) || 1200,
          points: Array.isArray(parsed.points) ? this.normalizeAutoPoints(parsed.points) : []
        };
      }
    } catch (error) {
      console.warn('Không thể đọc cấu hình auto click:', error.message);
    }
    return {
      interval: 1200,
      points: []
    };
  }

  normalizeAutoPoints(points) {
    return points
      .map((point) => ({
        offsetX: Number(point.offsetX),
        offsetY: Number(point.offsetY)
      }))
      .filter((point) => Number.isFinite(point.offsetX) && Number.isFinite(point.offsetY));
  }

  saveAutoClickConfig(partial = {}) {
    const nextConfig = {
      ...this.autoClickConfig,
      ...partial
    };

    if (partial.interval !== undefined) {
      nextConfig.interval = Math.max(200, Number(partial.interval) || 1200);
    } else {
      nextConfig.interval = Math.max(200, Number(nextConfig.interval) || 1200);
    }

    if (partial.points) {
      nextConfig.points = this.normalizeAutoPoints(partial.points);
    } else if (!Array.isArray(nextConfig.points)) {
      nextConfig.points = [];
    }

    this.autoClickConfig = nextConfig;

    try {
      fs.writeFileSync(this.autoConfigPath, JSON.stringify(this.autoClickConfig, null, 2), 'utf8');
    } catch (error) {
      console.error('Không thể lưu cấu hình auto click:', error.message);
    }

    return this.autoClickConfig;
  }

  writeTempScript(prefix, content) {
    const safePrefix = prefix || 'script';
    const fileName = `${safePrefix}-${Date.now()}-${Math.random().toString(36).slice(2, 8)}.ps1`;
    const scriptPath = path.join(this.appDir, fileName);
    fs.writeFileSync(scriptPath, content, 'utf8');
    return scriptPath;
  }

  cleanupTempScript(scriptPath) {
    if (!scriptPath) return;
    try {
      if (fs.existsSync(scriptPath)) {
        fs.unlinkSync(scriptPath);
      }
    } catch (error) {
      console.warn('Không thể xóa script tạm:', scriptPath);
    }
  }

  killFlashProcess() {
    if (this.flashProcess) {
      this.flashProcess.kill();
      this.flashProcess = null;
    }
    this.stopAutoClick({ silent: true });
  }

  async startRecordClick(config = {}) {
    if (!config.targetWindow || !config.targetWindow.handle) {
      return { success: false, error: 'Thiếu thông tin cửa sổ đích.' };
    }

    // Dừng record cũ nếu có
    await this.stopRecordClick({ silent: true });

    this.recordClickTarget = {
      pid: config.targetWindow.pid,
      title: config.targetWindow.title,
      handle: Number(config.targetWindow.handle) || config.targetWindow.handle
    };

    console.log('Starting record click for window:', this.recordClickTarget);
    const handleValue = this.recordClickTarget.handle;
    const scriptContent = this.buildRecordClickScript(handleValue);

    const scriptPath = this.writeTempScript('recordClick', scriptContent);
    this.recordClickScriptPath = scriptPath;
    console.log('Record click script path:', scriptPath);

    return await new Promise((resolve) => {
      this.recordClickProcess = spawn('powershell', ['-ExecutionPolicy', 'Bypass', '-File', scriptPath], {
        cwd: this.appDir,
        windowsHide: true,
        stdio: ['ignore', 'pipe', 'pipe']
      });

      this.recordClickProcess.stdout.on('data', (data) => {
        const message = data.toString().trim();
        if (!message) return;

        // Xử lý từng dòng (có thể có nhiều dòng)
        const lines = message.split('\n').filter(line => line.trim());
        lines.forEach(line => {
          try {
            const parsed = JSON.parse(line.trim());
            if (parsed.type === 'click' && parsed.point) {
              // Gửi điểm click về renderer process
              console.log('Recorded click point:', parsed.point);
              if (this.mainWindow) {
                this.mainWindow.webContents.send('record-click-point', {
                  point: parsed.point
                });
              }
            } else if (parsed.type === 'error') {
              console.error('Record click error:', parsed.message);
              if (this.mainWindow) {
                this.mainWindow.webContents.send('record-click-error', {
                  message: parsed.message
                });
              }
            } else if (parsed.type === 'info') {
              console.log('Record click info:', parsed.message);
            }
          } catch (e) {
            // Không phải JSON, có thể là debug message
            console.log('Record click output:', line);
          }
        });
      });

      this.recordClickProcess.stderr.on('data', (data) => {
        const errorMsg = data.toString();
        console.error('Record click stderr:', errorMsg);
        // Gửi lỗi về renderer nếu có
        if (this.mainWindow && errorMsg.trim()) {
          this.mainWindow.webContents.send('record-click-error', {
            message: errorMsg.trim()
          });
        }
      });

      this.recordClickProcess.on('exit', (code) => {
        this.cleanupRecordClickProcess();
        if (code !== 0 && code !== null) {
          console.log('Record click process exited with code:', code);
        }
      });

      resolve({ success: true });
    });
  }

  buildRecordClickScript(handleValue) {
    return `Add-Type @"
using System;
using System.Runtime.InteropServices;
public class RecordClicker {
  [DllImport("user32.dll")]
  public static extern bool GetWindowRect(IntPtr hWnd, out RECT lpRect);
  [DllImport("user32.dll")]
  public static extern bool IsWindow(IntPtr hWnd);
  [DllImport("user32.dll")]
  public static extern IntPtr SetWindowsHookEx(int idHook, LowLevelMouseProc lpfn, IntPtr hMod, uint dwThreadId);
  [DllImport("user32.dll")]
  public static extern bool UnhookWindowsHookEx(IntPtr hHook);
  [DllImport("user32.dll")]
  public static extern IntPtr CallNextHookEx(IntPtr hHook, int nCode, IntPtr wParam, IntPtr lParam);
  [DllImport("user32.dll")]
  public static extern IntPtr WindowFromPoint(POINT Point);
  [DllImport("user32.dll")]
  public static extern IntPtr GetAncestor(IntPtr hWnd, uint gaFlags);
  [DllImport("user32.dll")]
  public static extern bool ScreenToClient(IntPtr hWnd, ref POINT lpPoint);
  [DllImport("kernel32.dll")]
  public static extern IntPtr GetModuleHandle(string lpModuleName);
  [DllImport("user32.dll")]
  public static extern uint GetWindowThreadProcessId(IntPtr hWnd, out uint lpdwProcessId);
  public struct RECT {
    public int Left;
    public int Top;
    public int Right;
    public int Bottom;
  }
  public struct POINT {
    public int X;
    public int Y;
  }
  public struct MSLLHOOKSTRUCT {
    public POINT pt;
    public uint mouseData;
    public uint flags;
    public uint time;
    public IntPtr dwExtraInfo;
  }
  public delegate IntPtr LowLevelMouseProc(int nCode, IntPtr wParam, IntPtr lParam);
  public const int WH_MOUSE_LL = 14;
  public const int WM_LBUTTONDOWN = 0x0201;
  public const uint GA_ROOT = 2;
}
"@
$script:handle = [IntPtr]${handleValue}
$script:hook = [IntPtr]::Zero
$script:rect = New-Object RecordClicker+RECT
$script:hookProc = [RecordClicker+LowLevelMouseProc]{
  param($nCode, $wParam, $lParam)
  if ($nCode -ge 0 -and $wParam.ToInt32() -eq [RecordClicker]::WM_LBUTTONDOWN) {
    try {
      $hookStruct = [System.Runtime.InteropServices.Marshal]::PtrToStructure($lParam, [Type][RecordClicker+MSLLHOOKSTRUCT])
      $clickX = $hookStruct.pt.X
      $clickY = $hookStruct.pt.Y
      $clickPoint = New-Object RecordClicker+POINT
      $clickPoint.X = $clickX
      $clickPoint.Y = $clickY
      $clickedWindow = [RecordClicker]::WindowFromPoint($clickPoint)
      if ($clickedWindow -ne [IntPtr]::Zero) {
        $rootWindow = [RecordClicker]::GetAncestor($clickedWindow, [RecordClicker]::GA_ROOT)
        if ($rootWindow.ToInt64() -eq $script:handle.ToInt64()) {
          if ([RecordClicker]::GetWindowRect($script:handle, [ref]$script:rect)) {
            $clientPoint = $clickPoint
            [RecordClicker]::ScreenToClient($script:handle, [ref]$clientPoint) | Out-Null
            $offsetX = $clientPoint.X
            $offsetY = $clientPoint.Y
            if ($offsetX -ge 0 -and $offsetY -ge 0) {
              $result = @{
                type = "click"
                point = @{
                  offsetX = $offsetX
                  offsetY = $offsetY
                  screenX = $clickX
                  screenY = $clickY
                }
              } | ConvertTo-Json -Compress
              [Console]::Out.WriteLine($result)
            }
          }
        }
      }
    } catch {
      # Bỏ qua lỗi
    }
  }
  return [RecordClicker]::CallNextHookEx($script:hook, $nCode, $wParam, $lParam)
}
Add-Type -AssemblyName System.Windows.Forms
$script:hook = [RecordClicker]::SetWindowsHookEx([RecordClicker]::WH_MOUSE_LL, $script:hookProc, [RecordClicker]::GetModuleHandle($null), 0)
if ($script:hook -eq [IntPtr]::Zero) {
  $errorMsg = "Không thể thiết lập hook. Mã lỗi: " + [System.Runtime.InteropServices.Marshal]::GetLastWin32Error()
  $error = @{
    type = "error"
    message = $errorMsg
  } | ConvertTo-Json -Compress
  [Console]::Out.WriteLine($error)
  exit 1
}
$initMsg = @{
  type = "info"
  message = "Hook đã được thiết lập thành công"
} | ConvertTo-Json -Compress
[Console]::Out.WriteLine($initMsg)
try {
  while ($true) {
    [System.Windows.Forms.Application]::DoEvents()
    Start-Sleep -Milliseconds 50
    if (-not [RecordClicker]::IsWindow($script:handle)) {
      $closeMsg = @{
        type = "info"
        message = "Cửa sổ đã đóng"
      } | ConvertTo-Json -Compress
      [Console]::Out.WriteLine($closeMsg)
      break
    }
  }
} catch {
  $error = @{
    type = "error"
    message = $_.Exception.Message
  } | ConvertTo-Json -Compress
  [Console]::Out.WriteLine($error)
} finally {
  if ($script:hook -ne [IntPtr]::Zero) {
    [RecordClicker]::UnhookWindowsHookEx($script:hook) | Out-Null
  }
}`;
  }

  async stopRecordClick(options = {}) {
    const silent = options && options.silent;
    if (this.recordClickProcess) {
      try {
        this.recordClickProcess.kill();
      } catch (error) {
        console.error('Không thể dừng record click:', error);
      }
    }

    this.cleanupRecordClickProcess();

    if (!silent && this.mainWindow) {
      this.mainWindow.webContents.send('record-click-stopped', {
        success: true
      });
    }

    return { success: true };
  }

  cleanupRecordClickProcess() {
    if (this.recordClickProcess) {
      this.recordClickProcess.removeAllListeners();
      this.recordClickProcess = null;
    }

    this.cleanupTempScript(this.recordClickScriptPath);
    this.recordClickScriptPath = null;
    this.recordClickTarget = null;
  }
}

module.exports = ItemController;

